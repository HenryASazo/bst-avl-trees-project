# Binary Search Tree (BST) and AVL Tree Implementation

This repository contains my university project that implements a **Binary Search Tree (BST)** and **AVL Tree**, along with their complete functionalities. The project demonstrates my understanding of data structures, algorithms, and balancing techniques.

## Project Overview

**Objective**: To implement and compare the operations of a basic BST and a self-balancing AVL tree, showcasing their functionalities and efficiency.  
**Programming Language**: C++, Cmake

## Features

- **Binary Search Tree (BST)**:
  - Insertion, deletion, and search operations.
  - Traversal methods: in-order, pre-order, and post-order.
- **AVL Tree**:
  - Self-balancing after insertions and deletions.
  - Rotations (single and double) to maintain balance.
  - All standard traversal methods.
- **Comparative Analysis**:
  - Analyzing differences in efficiency between BST and AVL tree operations.

## How It Works

- The BST provides a basic implementation of a binary search tree where nodes are organized based on their keys.
- The AVL tree is an enhanced version that ensures height balance through rotations after every insertion or deletion.
- Operations in both structures are implemented to handle edge cases and ensure correctness.

## Usage

1. **Setup**:
   - Clone the repository and compile the code in your preferred IDE.
2. **Execution**:
   - Run the code on docker.
   - Test the functionalities such as insertion, deletion, and search.

## Learning Outcomes

Through this project, I gained hands-on experience with:

- Implementing and debugging complex data structures.
- Understanding the importance of balancing in trees for efficient operations.
- Comparing time complexities of unbalanced and balanced trees.

## Future Enhancements

- Add visualization for tree structures to demonstrate operations dynamically.
- Extend the implementation to support additional tree types (e.g., Red-Black Trees).
- Include unit tests to validate all functionalities programmatically.
